(ns forge.db
  (:require [clojure.edn :as edn]
            [clojure.java.io :as io]
            [forge.base :refer :all]
            [malli.core :as m]
            [malli.error :as me]
            [malli.generator :as mg]))

(declare schemas
         properties-file
         db-properties)

(defn schema-of [k]
  (safe-get schemas k))

(defn schema-type [schema]
  (if (vector? schema)
    (schema 0)
    schema))

(defmulti malli-form schema-type)
(defmethod malli-form :default [schema] schema)

(defmethod malli-form :s/number  [_] number?)
(defmethod malli-form :s/nat-int [_] nat-int?)
(defmethod malli-form :s/int     [_] int?)
(defmethod malli-form :s/pos     [_] pos?)
(defmethod malli-form :s/pos-int [_] pos-int?)

(defmethod malli-form :s/sound [_] :string)

(defmethod malli-form :s/image [_]
  [:map {:closed true}
   [:file :string]
   [:sub-image-bounds {:optional true} [:vector {:size 4} nat-int?]]])

(defmethod malli-form :s/animation [_]
  [:map {:closed true}
   [:frames :some] ; FIXME actually images
   [:frame-duration pos?]
   [:looping? :boolean]])

(defn- type->id-namespace [property-type]
  (keyword (name property-type)))

(defmethod malli-form :s/one-to-one [[_ property-type]]
  [:qualified-keyword {:namespace (type->id-namespace property-type)}])

(defmethod malli-form :s/one-to-many [[_ property-type]]
  [:set [:qualified-keyword {:namespace (type->id-namespace property-type)}]])

(defn- attribute-form
  "Can define keys as just keywords or with schema-props like [:foo {:optional true}]."
  [ks]
  (for [k ks
        :let [k? (keyword? k)
              schema-props (if k? nil (k 1))
              k (if k? k (k 0))]]
    (do
     (assert (keyword? k))
     (assert (or (nil? schema-props) (map? schema-props)) (pr-str ks))
     [k schema-props (malli-form (schema-of k))])))

(defn- map-form [ks]
  (apply vector :map {:closed true} (attribute-form ks)))

(defmethod malli-form :s/map [[_ ks]]
  (map-form ks))

(defmethod malli-form :s/map-optional [[_ ks]]
  (map-form (map (fn [k] [k {:optional true}]) ks)))

(defn- namespaced-ks [ns-name-k]
  (filter #(= (name ns-name-k) (namespace %))
          (keys schemas)))

(defmethod malli-form :s/components-ns [[_ ns-name-k]]
  (malli-form [:s/map-optional (namespaced-ks ns-name-k)]))

(defn property-type [{:keys [property/id]}]
  (keyword "properties" (namespace id)))

(defn property-types []
  (filter #(= "properties" (namespace %))
          (keys schemas)))

(defn schema-of-property [property]
  (schema-of (property-type property)))

(defn- invalid-ex-info [m-schema value]
  (ex-info (str (me/humanize (m/explain m-schema value)))
           {:value value
            :schema (m/form m-schema)}))

(defn validate! [property]
  (let [m-schema (-> property
                     schema-of-property
                     malli-form
                     m/schema)]
    (when-not (m/validate m-schema property)
      (throw (invalid-ex-info m-schema property)))))

(defn k->default-value [k]
  (let [schema (schema-of k)]
    (cond
     (#{:s/one-to-one :s/one-to-many} (schema-type schema)) nil

     ;(#{:s/map} type) {} ; cannot have empty for required keys, then no Add Component button

     :else (mg/generate (malli-form schema) {:size 3}))))

(defn- async-write-to-file! []
  (->> db-properties
       vals
       (sort-by property-type)
       (map recur-sort-map)
       doall
       (async-pprint-spit! properties-file)))

(defn get-raw [id]
  (safe-get db-properties id))

(defn all-raw [type]
  (->> (vals db-properties)
       (filter #(= type (property-type %)))))

(def ^:private undefined-data-ks (atom #{}))

(comment
 #{:frames
   :looping?
   :frame-duration
   :file
   :sub-image-bounds})

(declare build)

(defmulti edn->value (fn [schema v]
                       (when schema  ; undefined-data-ks
                         (schema-type schema))))
(defmethod edn->value :default [_schema v] v)

(defmethod edn->value :s/one-to-many [_ property-ids]
  (set (map build property-ids)))

(defmethod edn->value :s/one-to-one [_ property-id]
  (build property-id))

(defn- build* [property]
  (apply-kvs property
             (fn [k v]
               (let [schema (try (schema-of k)
                                 (catch Throwable _t
                                   (swap! undefined-data-ks conj k)
                                   nil))
                     v (if (map? v)
                         (build* v)
                         v)]
                 (try (edn->value schema v)
                      (catch Throwable t
                        (throw (ex-info " " {:k k :v v} t))))))))

(defn build [id]
  (build* (get-raw id)))

(defn build-all [type]
  (map build* (all-raw type)))

(defn db-update! [{:keys [property/id] :as property}]
  {:pre [(contains? property :property/id)
         (contains? db-properties id)]}
  (validate! property)
  (alter-var-root #'db-properties assoc id property)
  (async-write-to-file!))

(defn db-delete! [property-id]
  {:pre [(contains? db-properties property-id)]}
  (alter-var-root #'db-properties dissoc property-id)
  (async-write-to-file!))

(defn db-migrate [property-type update-fn]
  (doseq [id (map :property/id (all-raw property-type))]
    (println id)
    (alter-var-root #'db-properties update id update-fn))
  (async-write-to-file!))

(defn property->image [{:keys [entity/image entity/animation]}]
  (or image
      (first (:frames animation))))

(defn init [{:keys [schema properties]}]
  (bind-root #'schemas (-> schema io/resource slurp edn/read-string))
  (bind-root #'properties-file (io/resource properties))
  (let [properties (-> properties-file slurp edn/read-string)]
    (assert (or (empty? properties)
                (apply distinct? (map :property/id properties))))
    (run! validate! properties)
    (bind-root #'db-properties (zipmap (map :property/id properties) properties))))
