(ns gdl.graphics
  "
  This interface encapsulates communication with the graphics processor. Depending on the available hardware and the current Application configuration, access to GL20 and GL30 are provided here.

If supported by the backend, this interface lets you query the available display modes (graphics resolution and color depth) and change it.

This interface can be used to switch between continuous and non-continuous rendering (see setContinuousRendering(boolean)), and to explicitly requestRendering().

There are many more utility classes that are not directly generated by the Graphics interfaces. See VertexArray , VertexBufferObject, IndexBufferObject, Mesh, ShaderProgram and FrameBuffer, BitmapFont, Batch and so on. All these classes are managed, meaning they don't need to be reloaded on a context loss. Explore the com.badlogic.gdx.graphics package for more classes that might come in handy.

  "
  (:require [com.badlogic.gdx.graphics.g2d.bitmap-font :as bitmap-font]
            [com.badlogic.gdx.graphics.g2d.freetype :as freetype]
            [com.badlogic.gdx.math.vector3 :as vector3]
            gdl.graphics.bitmap-font
            )
  (:import (clojure.lang ILookup)
           (com.badlogic.gdx.graphics OrthographicCamera)))

(defprotocol Graphics
  (delta-time [_]
              "the time span between the current frame and the last frame in seconds."
              )
  (frames-per-second [_]
                     "the average number of frames per second"
                     )
  (set-cursor! [_ cursor]
               "
Only viable on the lwjgl-backend and on the gwt-backend. Browsers that support cursor:url() and support the png format (the pixmap is converted to a data-url of type image/png) should also support custom cursors. Will set the mouse cursor image to the image represented by the Cursor. It is recommended to call this function in the main render thread, and maximum one time per frame.

Parameters:
    cursor - the mouse cursor as a Cursor
               "
               )
  (cursor [_ pixmap hotspot-x hotspot-y]

          "
Create a new cursor represented by the Pixmap. The Pixmap must be in RGBA8888 format, width & height must be powers-of-two greater than zero (not necessarily equal) and of a certain minimum size (32x32 is a safe bet), and alpha transparency must be single-bit (i.e., 0x00 or 0xFF only). This function returns a Cursor object that can be set as the system cursor by calling setCursor(Cursor) .

Parameters:
    pixmap - the mouse cursor image as a Pixmap
    xHotspot - the x location of the hotspot pixel within the cursor image (origin top-left corner)
    yHotspot - the y location of the hotspot pixel within the cursor image (origin top-left corner)
Returns:
    a cursor object that can be used by calling setCursor(Cursor) or null if not supported
          "


          )
  (clear! [_ [r g b a]]
          [_ r g b a]
          "
Clears the color buffers with the specified color."
          )
  (texture [_ file-handle]
           "See `gdl.graphics.texture`"

           )
  (pixmap [_ width height pixmap-format]
          [_ file-handle]
          "See `gdl.graphics.pixmap`."
          )
  (fit-viewport [_ width height camera])
  (sprite-batch [_]))

(defn generate-font [file-handle params]
  (freetype/generate-font file-handle params))

(defn orthographic-camera
  ([]
   (proxy [OrthographicCamera ILookup] []
     (valAt [k]
       (let [^OrthographicCamera this this]
         (case k
           :camera/combined (.combined this)
           :camera/zoom (.zoom this)
           :camera/frustum {:frustum/plane-points (mapv vector3/clojurize (.planePoints (.frustum this)))}
           :camera/position (vector3/clojurize (.position this))
           :camera/viewport-width  (.viewportWidth  this)
           :camera/viewport-height (.viewportHeight this))))))
  ([& {:keys [y-down? world-width world-height]}]
   (doto (orthographic-camera)
     (OrthographicCamera/.setToOrtho y-down? world-width world-height))))

(extend com.badlogic.gdx.graphics.g2d.BitmapFont
  gdl.graphics.bitmap-font/BitmapFont
  {:draw! bitmap-font/draw!})
